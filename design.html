<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <link rel="stylesheet" type="text/css" href="html.css" />
    <title>JAS - Class Design</title>
  </head>
  <body class="main">
    <h1>JAS class and package design overview</h1>

<p>
In ths document we give an overview on the structure 
of the interfaces, classes and packages of JAS.
In the first three sections we focus on the structure 
of the required types and the creation of the corresponding objects.
In the next three sections we focus on the functional aspects of 
the types, i.e. their constructors and methods.
For a discussion of other design alternatives see
the <a href="problems.html">problems</a> document.
</p>


<h2>1. Recursive ring element design</h2>

<p>
The next figure gives an overview of the central interfaces and classes.
The interface <code>RingElem</code> defines a <strong>recursive type</strong> 
which defines the functionality (see next section) of the 
polynomial coefficients and is also implemented by the 
polynomials itself. So polynomials can be taken as coefficients 
for other polynomials, thus defining a recursive polynomial ring structure.
</p>

<p>
Since the construction of constant ring elements has been difficult
in previuos designs, we separated the creational aspects of ring elements
into <strong>ring factories</strong> with sufficient context information. 
The minimal factory functionality is defined by the interface 
<code>RingFactory</code>.
Constructors for polynomial rings will then require factories for
the coefficients so that the construction of polynomials over these
coefficient rings poses no problem. 
The ring factories are additionaly required because of the 
Java generic type design. I.e. if <code>C</code> is a generic type name
it is not possible to construct an new object with <code>new C()</code>.
Even if this would be possible, one can not specify constructor signatures 
in Java interfaces, e.g. to construct a one or zero constant ring element.
Recursion is again achieved by using polynomial factories as 
coefficient factories in recursive polynomial rings.
Constructors for polynomials will always require 
a polynomial factory parameter which knows 
all details about the polynomial ring under consideration.
</p>

<p class="center" >
<a href="images/overview-recursive.png" 
   target="diagram"
   ><img src="images/overview-recursive.png" alt="JAS type overview" /></a>
<br />
UML diagram of JAS types
</p>


<h2>2. Coefficients and polynomials</h2>

<p>
We continue the discussion of the next layer of classes in the
the above figure.
</p>

<p>
Elementary <strong>coefficient classes</strong>, such as 
<code>BigRational</code> or <code>BigInteger</code>, implement both 
the <code>RingElem</code> and <code>RingFactory</code> interfaces. 
This is convenient, since these factories do not need further context 
information.
In the implementation of the interfaces the type parameter 
<code>C extends RingElem&lt;C&gt;</code> is simultaneously bound 
to the respective class, e.g. <code>BigRational</code>.
<strong>Coefficient objects</strong> can in most cases created directly 
via the respective class constructors, but also via the factory methods. 
E.g. the object representing the rational number 2 can be created by 
<code>new BigRational(2)</code> or by 
<code>fac = new BigRational()</code>, <code>fac.fromInteger(2)</code> and 
the object representing the rational number 1/2 can be created by 
<code>new BigRational(1,2)</code> or by 
<code>fac.parse("1/2")</code>.
</p>

<p>
<strong>Generic polynomials</strong> are implemented in the 
<code>GenPolynomial</code> class, which has a type parameter 
<code>C extends RingElem&lt;C&gt;</code> 
for the coefficient type. So all operations on coefficients required
in polynomial arithmetic and manipulation are guaranteed to exist by the 
<code>RingElem</code> interface. The constructors of the polynomials 
always require a matching polynomial factory. 
The <strong>generic polynomial factory</strong> is implemented in the class 
<code>GenPolynomialRing</code>, again with type parameter 
<code>C extends RingElem&lt;C&gt;</code> (not <code>RingFactory</code>).
The polynomial factory however implements the interface 
<code>RingFactory&lt;C extends RingElem&lt;C&gt;&gt;</code> so that 
it can also be used recursively.
The constructors for <code>GenPolynomialRing</code> require at least 
parameters for a coefficient factory and the number of variables 
of the polynomial ring.
</p>

<p>
Having generic polynomial and elementary coefficient implementations 
one can attempt to construct <strong>polynomial objects</strong>. 
The type is first created by binding the type parameter 
<code>C extends RingElem&lt;C&gt;</code> to the desired coefficient type, 
e.g. <code>BigRational</code>. So we arrive at the type
<code>GenPolynomial&lt;BigRational&gt;</code>.
Polynomial objects are then created via the respective polynomial factory
of type <code>GenPolynomialRing&lt;BigRational&gt;</code>, 
which is created by binding the generic coefficient type of the 
generic polynomial factory to the desired coefficient type, 
e.g. <code>BigRational</code>.
A <strong>polynomial factory object</strong> is created from a 
coefficient factory object and the number of variables in the 
polynomial ring as usual with the <code>new</code> operator via one 
of its constructors.
Given an object <code>coFac</code> of type <code>BigRational</code>,
e.g. created with <code>new BigRational()</code>, a polynomial factory
object <code>pfac</code> of the above described type could be created by 
<code>new GenPolynomialRing&lt;BigRational&gt;(coFac,5)</code>.
I.e. we specified a polynomial ring with 5 variables over 
the rational numbers.
A polynomial object <code>p</code> of the above described type can then
be created by any method defined in <code>RingFactory</code>, 
e.g. by <code>pfac.getONE()</code>, 
<code>pfac.fromInteger(1)</code>, <code>pfac.random(3)</code>
or <code>pfac.parse("(1)")</code>.
</p>

<p>
Since <code>GenPolynomial</code> itself implements the 
<code>RingElem</code> interface, they can also be used recursively
as coefficients. 
We continue the polynomial example and are going to use polynomials over
the rational numbers as coefficients of a new polynomial. 
The type is then 
<code>GenPolynomial&lt;GenPolynomial&lt;BigRational&gt;&gt;</code>
and the polynomial factory has type
<code>GenPolynomial<b>Ring</b>&lt;GenPolynomial&lt;BigRational&gt;&gt;</code>.
Using the polynomial coefficient factory <code>pfac</code> from above
a recursive polynomial factory <code>rfac</code> could be created by 
<code>new GenPolynomialRing&lt;GenPolynomial&lt;BigRational&gt;&gt;(pfac,3)</code>.
The creation of a recursive polynomial object <code>r</code> of the 
above described type is then as a easy as before
e.g. by <code>rfac.getONE()</code>, 
<code>rfac.fromInteger(1)</code> or <code>rfac.random(3)</code>.
</p>


<h2>3. Solvable polynomials</h2>

<p>
We turn now to the last layer of classes in the the above figure.
</p>

<p>
The generic polynomials are intended as super class for further 
types of polynomial rings. As one example we take so called 
<strong>solvable polynomials</strong>, which are like normal polynomials 
but are equipped with a new non-commutative multiplication. 
They are implemented in the class <code>GenSolvablePolynomial</code> 
which extends <code>GenPolynomial</code> and inherits all methods 
except <code>clone()</code> and <code>multiply()</code>.
The class also has a type parameter <code>C extends RingElem&lt;C&gt;</code> 
for the coefficient type.
Note, that the inherited methods are in fact creating solvable polynomials 
since they employ the solvable polynomial factory for the creation of any
new polynomial internally. Only the formal method return type is that 
of <code>GenPolynomial</code>, the run-time type is 
<code>GenSolvablePolynomial</code> to which they can be casted at any time.
The <strong>factory for solvable polynomials</strong> is implemented 
by the class <code>GenSolvablePolynomialRing</code> which also 
extends the generic polynomial factory. So this factory can also be used 
in the constructors of <code>GenPolynomial</code> via <code>super()</code> 
to produce in fact solvable polynomials internally. The data structure 
is enhanced by a table of non-commutative relations defining the 
new multiplication. The constructors delegate most things to the 
corresponding super class constructors and additionally have a 
parameter for the <code>RelationTable</code> to be used.
Also the methods delegate the work to the respective super class methods 
where possible and then handle the non-commutative multiplication relations 
separately.
</p>

<p>
The construction of <strong>solvable polynomial objects</strong>
follows directly that of polynomial objects.
The type is created by binding the type parameter 
<code>C extends RingElem&lt;C&gt;</code> to the desired coefficient type, 
e.g. <code>BigRational</code>. So we have the type
<code>GenSolvablePolynomial&lt;BigRational&gt;</code>.
Solvable polynomial objects are then created via the respective 
solvable polynomial factory of type 
<code>GenSolvablePolynomialRing&lt;BigRational&gt;</code>, 
which is created by binding the generic coefficient type of the 
generic polynomial factory to the desired coefficient type, 
e.g. <code>BigRational</code>.
A <strong>solvable polynomial factory object</strong> is created from a 
coefficient factory object, the number of variables in the 
polynomial ring and a table containing the defining non-commutative relations
as usual with the <code>new</code> operator via one of its constructors.
Given an object <code>coFac</code> of type <code>BigRational</code>
as before, a polynomial factory object <code>spfac</code> 
of the above described type could be created by 
<code>new GenSolvablePolynomialRing&lt;BigRational&gt;(coFac,5)</code>.
I.e. we specified a polynomial ring with 5 variables over 
the rational numbers with no commutator relations.
A solvable polynomial object <code>p</code> of the above described type 
can then be created by any method defined in <code>RingFactory</code>, 
e.g. by <code>spfac.getONE()</code>, 
<code>spfac.fromInteger(1)</code>, <code>spfac.random(3)</code>
or <code>spfac.parse("(1)")</code>.
Some care is needed to create <code>RelationTable</code> objects 
since its constructor requires the solvable polynomial ring which 
is under construction as parameter. It is most convenient to first
create a <code>GenSolvablePolynomialRing</code> with an 
empty relation table and then to add the defining relations.
</p>


<h2>4. Ring element and factory functionality</h2>

<p>
The following sections and the next figure gives an overview 
of the functionality of the main interfaces and polynomial classes.
</p>

<p>
The <code>RingElem</code> interface has a generic type parameter 
<code>C</code> which is constrained to a type with the same functionality
<code>C extends RingElem&lt;C&gt;</code>.
It defines the usual methods required for ring arithmetic such as
<code>C sum(C S); C subtract(C S); C negate(); C abs();
      C multiply(C S); C divide(C S); C remainder(C S); C inverse();
</code>
Although the actual ring may not have inverses for every element
or some division algorithm we have included these methods in the definition.
In a case where there is no such function, the implementation may 
deliberately throw a <code>RuntimeException</code> or choose some 
other meaningful element to return.
The method <code>isUnit()</code> can be used to check if an element 
is invertible.
</p>
<p>
Besides the arithmetic method there are following testing methods
<code>boolean isZERO(); boolean isONE(); boolean isUnit();
    int signum();
    boolean equals(Object b); int hashCode(); int compareTo(C b); 
</code>
The first three test if the element is 0, 1 or a unit in the respective ring.
The <code>signum()</code> method defines the sign of the element (in case 
of an ordered ring).
<code>equals()</code>, <code>hashCode()</code> and <code>compareTo()</code> 
are required to keep Javas object machinery working in our sense. 
They are used when an element is put into a Java collection class, 
e.g. <code>Set</code>, <code>Map</code> or <code>SortedMap</code>.
The last method <code>C clone()</code> can be used to obtain a copy of the
actual element. As creational method one should better use the 
method <code>C copy(C a)</code> from the ring factory, but in Java 
it is more convenient to use the <code>clone()</code> method.
</p>

<p>
As mentioned before, the creational aspects of rings are separated 
into a ring factory. A ring factory is intended to store all context
information known or required for a specific ring. 
Every ring element should also know its ring factory, so all
constructors of ring element implementations require a parameter 
for the corresponding ring factory. Unfortunately constructors 
and their signature can not be specified in a Java interface.
The <code>RingFactory</code> interface also has a generic type parameter 
<code>C</code> which is constrained to a type with the ring element 
functionality <code>C extends RingElem&lt;C&gt;</code>.
The defined methods are 
<code>C getZERO(); C getONE();
      C fromInteger(long a); C fromInteger(java.math.BigInteger a);
      C random(int n); C copy(C c);
      C parse(String s); C parse(Reader r);
</code>
The first two create 0 and 1 of the ring.
The second two are used to embed a natural number into the ring 
and create the corresponding ring element.
The <code>copy()</code> method was intended as the main means to 
obtain a copy of a ring element, but it is now no more used in our 
implmentation. Instead the <code>clone()</code> method is used from 
the ring element interface.
The <code>random(int n)</code> method creates a random element of the 
respective ring. The parameter <code>n</code> specifies an appropriate 
maximal size for the created element. In case of coefficients it
usually means the maximal bit-length of the element, in case of 
polynomials it influences the coefficient size and the degrees. 
For polynomials there are <code>random()</code> methods with more 
parameters.
The two methods 
<code>C parse(String s)</code> and <code>C parse(Reader r)</code> 
create a ring element from some external string representation.
For coefficients this is mostly implemented directly and for 
polynomials the class <code>GenPolynomialTokenizer</code> is 
employed internally.
In the current implementation the external representation of 
coefficients may never contain white space and must always start 
with a digit.
In the future the ring factory will be enhanced by methods that
test if the ring is commutative, associative or has some 
other important property or the value of a property, 
e.g. is an euclidean ring, is a field, an integal domain, 
a uniqe factorization domain, its characteristic or if it is noetherian. 
</p>

<p class="center" >
<a href="images/overview-methods.png" 
   target="diagram"
   ><img src="images/overview-methods.png" alt="JAS type functionality" /></a>
<br />
UML diagram of JAS type functionality
</p>


<h2>5. Polynomial and polynomial factory functionality</h2>

<p>
We continue the discussion of the above figure 
with the generic polynomial and factory classes.
</p>

<p>
The <code>GenPolynomial</code> class has a generic type parameter 
<code>C</code> which is constrained to a type with the functionality
of ring elements <code>C extends RingElem&lt;C&gt;</code>.
Further the class implements a <code>RingElem</code> over itself
<code>RingElem&lt;GenPolynomial&lt;C&gt;&gt;</code> 
so that it can be used for the coefficients of an other polynomial ring.
The functionality of the ring element methods has already been explained 
in the previous section. 
There are two public and one protected constructors, each requires
at least a ring factory parameter <code>GenPolynomialRing&lt;C&gt; r</code>.
The first creates a zero polynomial
<code>GenPolynomial(. r)</code>,
the second creates a polynomial of one monomial with given coefficient 
and exponent tuple
<code>GenPolynomial(. r, C c, ExpVector e)</code>, 
the third creates a polynomial from the internal sorted map of an 
other polynomial
<code>GenPolynomial(. r, SortedMap&lt;ExpVector,C&gt; v)</code>.
Further there are methods to access parts of the polynomial 
like leading term, leading coefficient 
(still called leading base coefficient from the Aldes/SAC-2 tradition)
and leading monomial.
The <code>toString()</code> method creates as usual a string representation 
of the polynomials consisting of exponent tuples and coefficients. 
One variant of it takes an array of variable names and creates a string
consisting of coefficients and products of powers of variables.
The method <code>extend()</code> is used to embed the polynomial into the 
'bigger' polynomial ring specified in the first parameter. 
The embeded polynomial can also be multiplied by a power of a variable.
The <code>contract()</code> method returns a map of exponents and 
coefficients. The coefficients are polynomials belonging to the 
'smaller' polynomial ring specified in the first parameter. 
If the polynomial actually belongs to the smaller polynomial ring 
the map will contain only one pair, mapping the zero exponent vector
to the polynomial with variables removed.
A last group of methods computes (extended) greatest common divisors.
They work correct for univariate polynomials over a field but not 
for arbitrary multivatiate polynomials. These methods will be moved
to a new separate class in the future.
</p>

<p>
The <code>GenPolynomialRing</code> class has a generic type parameter 
<code>C</code> which is constrained to a type with the functionality
of ring elements <code>C extends RingElem&lt;C&gt;</code>.
Further the class implements a <code>RingFactory</code> over 
<code>GenPolynomial&lt;C&gt;</code> so that it can be used as
coefficient factory of a different polynomial ring.
The constructors require at least a factory for the coefficents as
first parameter of type <code>RingFactory&lt;C&gt;</code>
and the number of variables in the second parameter.
A third parameter can optionally specify a <code>TermOrder</code> 
and a fourth parameter can specify the names for the variables
of the polynomial ring.
Besides the methods required by the <code>RingFactory</code>
interface there are additional <code>random()</code> methods
which provide more control over the creation of random polynomials. 
They have the following parameters: 
the bitsize of random coefficients to be used in the 
<code>random()</code> method of the coefficient factory,
the number of terms (i.e. the length of the polynomial), 
the maximal degree in each variable
and the density of nozero exponents, i.e. the ratio of nonzero to 
zero exponents.
The <code>toString()</code> method creates a string representation 
of the polynomial ring consisting of the coefficient factory string 
representation, the tuple of variable names and the string representation 
of the term order. 
The <code>extend()</code> and <code>contract()</code> methods
create 'bigger' respectively 'smaller' polynomial rings. 
Both methods take a parameter of how many variables are to be added 
or removed form the actual polynomial ring.
<code>extend()</code> will setup an elimination term order consisting 
of two times the actual term order when ever possible.
</p>


<h2>6. Solvable polynomial and solvable polynomial factory functionality</h2>

<p>
We continue the discussion of the above figure 
with the generic solvable polynomial and factory classes.
</p>

<p>
The <code>GenSolvablePolynomial</code> class has a generic type parameter 
<code>C</code> which is constrained to a type with the functionality
of ring elements <code>C extends RingElem&lt;C&gt;</code>.
The class extends the <code>GenPolynomial</code> class. It inherits 
all additive functionality and overwrites the multiplicative 
functionality with a new non-commutative multiplication method.
Unfortunately it <em>cannot</em> implement a <code>RingElem</code> 
over itself <code>RingElem&lt;GenSolvablePolynomial&lt;C&gt;&gt;</code> 
but can only inherit the implementation of 
<code>RingElem&lt;GenPolynomial&lt;C&gt;&gt;</code> from its super class.
By this limitation a solvable polynomial can still be used as 
coefficent in another polynomial, but only with the type of its super 
class. The limitation comes form the erasure of template parameters in 
<code>RingElem&lt;...&gt;</code> to <code>RingElem</code> for the 
code generated. I.e. the generic interfaces become the same after
type erasure and it is not allowed to implement the same interface twice.
There are two public and one protected constructors as in the super class.
Each requires at least a ring factory parameter 
<code>GenSolvablePolynomialRing&lt;C&gt; r</code> 
which is stored in a variable of this type shadowing the variable 
with the same name of the super factory type. The rest of the 
initialization work is delegated to the super class constructor.
</p>

<p>
The <code>GenSolvablePolynomialRing</code> class has a generic type parameter 
<code>C</code> which is constrained to a type with the functionality
of ring elements <code>C extends RingElem&lt;C&gt;</code>.
The class extends the <code>GenPolynomialRing</code> class. 
It overwrites most methods to implement the new non-commutative 
methods.
Also this class cannot implement a <code>RingFactory</code> over 
<code>GenSolvablePolynomial&lt;C&gt;</code>. It only implements 
<code>RingFactory</code> over <code>GenPolynomial&lt;C&gt;</code>
by inheritance by the same reason of type erasure as above.
But it can be used as coefficient factory with the type of its super class
for a different polynomial ring.
One part of the constructors just restate the super class constructors
with the actual solvable type. A solvable polynomial ring however 
must know how to perform the non-commutative multiplication. 
To this end a data structure with the respective commutator relations 
is required. It is implemented in the <code>RelationTable</code> class.
The other part of the constructors additionaly takes a parameter of type
<code>RelationTable</code> to set the initial commutator relation table.
Some care is needed to create relation tables and solvable polynomial
factories since the relation table requires a solvable polynomial
factory as parameter in the constructor. So it is most advisable to 
create a solvable polynomial factory object with empty relation table
and to fill it with commutator relations after the constructor is 
completed but before the factory will be used.
There is also a new method <code>isAssociative()</code> which tries
to check if the commutator relations indeed define an associative 
algebra. This method should be extracted to the <code>RingFactory</code>
interface together with a method <code>isCommutative()</code>, 
since both are of general importance and not always fulfilled 
in our rings. E.g. <code>BigQuaternion</code> is not commutative 
and so is a polynomial ring over these coefficents is not commutative.
The same applies to associativity and the (not jet existing) class
<code>BigOctonion</code>.
</p>

<p>
This concludes the discussion of the main interfaces and classes 
of the Java algebra system.
</p>


<!--
<code></code> 
<p>
</p>
<p>
</p>
<pre>
</pre>
-->

<p><!--a href="README" target="readme" >README</a-->
</p>

    <hr />
<address><a href="mailto:kredel at rz.uni-mannheim.de">Heinz Kredel</a></address>
<p>
<!-- Created: Sat Mar 11 10:51:36 CET 2006 -->
<!-- hhmts start -->
Last modified: Thu May 31 22:56:28 CEST 2007
<!-- hhmts end -->
</p>
<p align="right" >
$Id$
</p>
  </body>
</html>
