<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>JAS - Class Design</title>
<style type="text/css">
body { background-color: #FFFFF5; } 
pre  { background-color: silver; 
       margin-left: 1em; 
       margin-right: 1em; 
       padding: 1em; 
     }
dt   { font-weight: bolder; 
       margin-top: 1em;
     }
.note { color: maroon; }
</style>
  </head>
  <body>
    <h1>JAS class and package design overview</h1>

<p>
In ths document we give an overview on the structure 
of the interfaces, classes and packages of JAS.
We focus on the structure of the required types and 
the creation of the corresponding objects.
For a discussion of other design alternatives see
the <a href="problems.html">problems</a> document.
</p>


<h2>1. Recursive ring element design</h2>

<p>
The next figure gives an overview of the central interfaces and classes.
The interface <code>RingElem</code> defines a <strong>recursive type</strong> 
which defines the functionality (see next section) of the 
polynomial coefficients and is also implemented by the 
polynomials itself. So polynomials can be taken as coefficients 
for other polynomials, thus defining a recursive polynomial ring structure.
</p>

<p>
Since the construction of constant ring elements has been difficult
in previuos designs, we separated the creational aspects of ring elements
into <strong>ring factories</strong> with sufficient context information. 
The minimal factory functionality is defined by the interface 
<code>RingFactory</code>.
Constructors for polynomial rings will then require factories for
the coefficients so that the construction of polynomials over these
coefficient rings poses no problem. 
The ring factories are additionaly required because of the 
Java generic type design. I.e. if <code>C</code> is a generic type name
it is not possible to construct an new object with <code>new C()</code>.
Even if this would be possible, one can not specify constructor signatures 
in Java interfaces, e.g. to construct a one or zero constant ring element.
Recursion is again achieved by using polynomial factories as 
coefficient factories in recursive polynomial rings.
Constructors for polynomials will always require 
a polynomial factory parameter which knows 
all details about the polynomial ring under consideration.
</p>

<p>
<a href="images/overview-recursive.png" 
   target="diagram"
   ><img src="images/overview-recursive.png"  /></a>
</p>


<h2>2. Coefficients and polynomials</h2>

<p>
We continue the discussion of the next layer of classes in the
the above figure.
</p>

<p>
Elementary <strong>coefficient classes</strong>, such as 
<code>BigRational</code> or <code>BigInteger</code>, implement both 
the <code>RingElem</code> and <code>RingFactory</code> interfaces. 
This is convenient, since these factories do not need further context 
information.
In the implementation of the interfaces the type parameter 
<code>C extends RingElem&lt;C&gt;</code> is simultaneously bound 
to the respective class, e.g. <code>BigRational</code>.
<strong>Coefficient objects</strong> can in most cases created directly 
via the respective class constructors, but also via the factory methods. 
E.g. the object representing the rational number 2 can be created by 
<code>new BigRational(2)</code> or by 
<code>fac = new BigRational()</code>, <code>fac.fromInteger(2)</code> and 
the object representing the rational number 1/2 can be created by 
<code>new BigRational(1,2)</code> or by 
<code>fac.parse("1/2")</code>.
</p>

<p>
<strong>Generic polynomials</strong> are implemented in the 
<code>GenPolynomial</code> class, which has a type parameter 
<code>C extends RingElem&lt;C&gt;</code> 
for the coefficient type. So all operations on coefficients required
in polynomial arithmetic and manipulation are guaranteed to exist by the 
<code>RingElem</code> interface. The constructors of the polynomials 
always require a matching polynomial factory. 
The <strong>generic polynomial factory</strong> is implemented in the class 
<code>GenPolynomialRing</code>, again with type parameter 
<code>C extends RingElem&lt;C&gt;</code> (not <code>RingFactory</code>).
The polynomial factory however implements the interface 
<code>RingFactory&lt;C extends RingElem&lt;C&gt;&gt;</code> so that 
it can also be used recursively.
The constructors for <code>GenPolynomialRing</code> require at least 
parameters for a coefficient factory and the number of variables 
of the polynomial ring.
</p>

<p>
Having generic polynomial and elementary coefficient implementations 
one can attempt to construct <strong>polynomial objects</strong>. 
The type is first created by binding the type parameter 
<code>C extends RingElem&lt;C&gt;</code> to the desired coefficient type, 
e.g. <code>BigRational</code>. So we arrive at the type
<code>GenPolynomial&lt;BigRational&gt;</code>.
Polynomial objects are then created via the respective polynomial factory
of type <code>GenPolynomialRing&lt;BigRational&gt;</code>, 
which is created by binding the generic coefficient type of the 
generic polynomial factory to the desired coefficient type, 
e.g. <code>BigRational</code>.
A <strong>polynomial factory object</strong> is created from a 
coefficient factory object and the number of variables in the 
polynomial ring as usual with the <code>new</code> operator via one 
of its constructors.
Given an object <code>coFac</code> of type <code>BigRational</code>,
e.g. created with <code>new BigRational()</code>, a polynomial factory
object <code>pfac</code> of the above described type could be created by 
<code>new GenPolynomialRing&lt;BigRational&gt;(coFac,5)</code>.
I.e. we specified a polynomial ring with 5 variables over 
the rational numbers.
A polynomial object <code>p</code> of the above described type can then
be created by any method defined in <code>RingFactory</code>, 
e.g. by <code>pfac.getONE()</code>, 
<code>pfac.fromInteger(1)</code>, <code>pfac.random(3)</code>
or <code>pfac.parse("(1)")</code>.
</p>

<p>
Since <code>GenPolynomial</code> itself implements the 
<code>RingElem</code> interface, they can also be used recursively
as coefficients. 
We continue the polynomial example and are going to use polynomials over
the rational numbers as coefficients of a new polynomial. 
The type is then 
<code>GenPolynomial&lt;GenPolynomial&lt;BigRational&gt;&gt;</code>
and the polynomial factory has type
<code>GenPolynomial<b>Ring</b>&lt;GenPolynomial&lt;BigRational&gt;&gt;</code>.
Using the polynomial coefficient factory <code>pfac</code> from above
a recursive polynomial factory <code>rfac</code> could be created by 
<code>new GenPolynomialRing&lt;GenPolynomial&lt;BigRational&gt;&gt;(pfac,3)</code>.
The creation of a recursive polynomial object <code>r</code> of the 
above described type is then as a easy as before
e.g. by <code>rfac.getONE()</code>, 
<code>rfac.fromInteger(1)</code> or <code>rfac.random(3)</code>.
</p>


<h2>3. Solvable polynomials</h2>

<p>
We turn now to the last layer of classes in the the above figure.
</p>

<p>
The generic polynomials are intended as super class for further 
types of polynomial rings. As one example we take so called 
<strong>solvable polynomials</strong>, which are like normal polynomials 
but are equipped with a new non-commutative multiplication. 
They are implemented in the class <code>GenSolvablePolynomial</code> 
which extends <code>GenPolynomial</code> and inherits all methods 
except <code>clone()</code> and <code>multiply()</code>.
The class also has a type parameter <code>C extends RingElem&lt;C&gt;</code> 
for the coefficient type.
Note, that the inherited methods are in fact creating solvable polynomials 
since they employ the solvable polynomial factory for the creation of any
new polynomial internally. Only the formal method return type is that 
of <code>GenPolynomial</code>, the run-time type is 
<code>GenSolvablePolynomial</code> to which they can be casted at any time.
The <strong>factory for solvable polynomials</strong> is implemented 
by the class <code>GenSolvablePolynomialRing</code> which also 
extends the generic polynomial factory. So this factory can also be used 
in the constructors of <code>GenPolynomial</code> via <code>super()</code> 
to produce in fact solvable polynomials internally. The data structure 
is enhanced by a table of non-commutative relations defining the 
new multiplication. The constructors delegate most things to the 
corresponding super class constructors and additionally have a 
parameter for the <code>RelationTable</code> to be used.
Also the methods delegate the work to the respective super class methods 
where possible and then handle the non-commutative multiplication relations 
separately.
</p>

<p>
The construction of <strong>solvable polynomial objects</strong>
follows directly that of polynomial objects.
The type is created by binding the type parameter 
<code>C extends RingElem&lt;C&gt;</code> to the desired coefficient type, 
e.g. <code>BigRational</code>. So we have the type
<code>GenSolvablePolynomial&lt;BigRational&gt;</code>.
Solvable polynomial objects are then created via the respective 
solvable polynomial factory of type 
<code>GenSolvablePolynomialRing&lt;BigRational&gt;</code>, 
which is created by binding the generic coefficient type of the 
generic polynomial factory to the desired coefficient type, 
e.g. <code>BigRational</code>.
A <strong>solvable polynomial factory object</strong> is created from a 
coefficient factory object, the number of variables in the 
polynomial ring and a table containing the defining non-commutative relations
as usual with the <code>new</code> operator via one of its constructors.
Given an object <code>coFac</code> of type <code>BigRational</code>
as before, a polynomial factory object <code>spfac</code> 
of the above described type could be created by 
<code>new GenSolvablePolynomialRing&lt;BigRational&gt;(coFac,5)</code>.
I.e. we specified a polynomial ring with 5 variables over 
the rational numbers with no commutator relations.
A solvable polynomial object <code>p</code> of the above described type 
can then be created by any method defined in <code>RingFactory</code>, 
e.g. by <code>spfac.getONE()</code>, 
<code>spfac.fromInteger(1)</code>, <code>spfac.random(3)</code>
or <code>spfac.parse("(1)")</code>.
Some care is needed to create <code>RelationTable</code> objects 
since its constructor requires the solvable polynomial ring which 
is under construction as parameter. It is most convenient to first
create a <code>GenSolvablePolynomialRing</code> with an 
empty relation table and then to add the defining relations.
</p>


<h2>4. Ring element and factory functionality</h2>

<p>
The following sections and the next figure gives an overview 
of the functionality of the main interfaces and polynomial classes.
</p>

<p>
The <code>RingElem</code> interface has a generic type parameter 
<code>C</code> which is constrained to a type with the same functionality
<code>C extends RingElem&lt;C&gt;</code>.
It defines the usual methods required for ring arithmetic such as
<code>C sum(C S); C subtract(C S); C negate(); C abs();
      C multiply(C S); C divide(C S); C remainder(C S); C inverse();
</code>
Although the actual ring may not have inverses for every element
or some division algorithm we have included these methods in the definition.
In a case where there is no such function, the implementation may 
deliberately throw a <code>RuntimeException</code> or choose some 
other meaningful element to return.
The method <code>isUnit()</code> can be used to check if an element 
is invertible.
</p>
<p>
Besides the arithmetic method there are following testing methods
<code>boolean isZERO(); boolean isONE(); boolean isUnit();
    int signum();
    boolean equals(Object b); int hashCode(); int compareTo(C b); 
</code>
The first three test if the element is 0, 1 or a unit in the respective ring.
The <code>signum()</code> method defines the sign of the element (in case 
of an ordered ring).
<code>equals()</code>, <code>hashCode()</code> and <code>compareTo()</code> 
are required to keep Javas object machinery working in our sense. 
They are used when an element is put into a Java collection class, 
e.g. <code>Set</code>, <code>Map</code> or <code>SortedMap</code>.
The last method <code>C clone()</code> can be used to obtain a copy of the
actual element. As creational method one should better use the 
method <code>C copy(C a)</code> from the ring factory, but in Java 
it is more convenient to use the <code>clone()</code> method.
</p>

<p>
As mentioned before, the creational aspects of rings are separated 
into a ring factory. A ring factory is intended to store all context
information known or required for a specific ring. 
Every ring element should also know its ring factory, so all
constructors of ring element implementations require a parameter 
for the corresponding ring factory. Unfortunately constructors 
and their signature can not be specified in a Java interface.
The <code>RingFactory</code> interface also has a generic type parameter 
<code>C</code> which is constrained to a type with the ring element 
functionality <code>C extends RingElem&lt;C&gt;</code>.
The defined methods are 
<code>C getZERO(); C getONE();
      C fromInteger(long a); C fromInteger(java.math.BigInteger a);
      C random(int n); C copy(C c);
      C parse(String s); C parse(Reader r);
</code>
The first two create 0 and 1 of the ring.
The second two are used to embed a natural number into the ring 
and create the corresponding ring element.
The <code>copy()</code> method was intended as the main means to 
obtain a copy of a ring element, but it is now no more used in our 
implmentation. Instead the <code>clone()</code> method is used from 
the ring element interface.
The <code>random(int n)</code> method creates a random element of the 
respective ring. The parameter <code>n</code> specifies an appropriate 
maximal size for the created element. In case of coefficients it
usually means the maximal bit-length of the element, in case of 
polynomials it influences the coefficient size and the degrees. 
For polynomials there are <code>random()</code> methods with more 
parameters.
The two methods 
<code>C parse(String s)</code> and <code>C parse(Reader r)</code> 
create a ring element from some external string representation.
For coefficients this is mostly implemented directly and for 
polynomials the class <code>GenPolynomialTokenizer</code> is 
employed internally.
In the current implementation the external representation of 
coefficients may never contain white space and must always start 
with a digit.
In the future the ring factory will be enhanced by methods that
test if the ring is commutative, associative or has some 
other important property or the value of the property, 
e.g. is an euclidean ring, is a field, an integal domain, 
a uniqe factorization domain, its characteristic or if it is noetherian. 
</p>

<p>
<a href="images/overview-methods.png" 
   target="diagram"
   ><img src="images/overview-methods.png"  /></a>
</p>


<h2>5. Polynomial and factory functionality</h2>

<p>
We continue the discussion of the above figure 
with the generic polynomial and factory classes.
</p>

<p>
Optionaly a <code>TermOrder</code> and names for the variables can 
be specified.
</p>


<p>
</p>

<p>
</p>


<!--
<p>
</p>
<pre>
</pre>
-->

<p><!--a href="README" target="readme" >README</a-->
</p>

    <hr />
<address><a href="mailto:kredel at rz.uni-mannheim.de">Heinz Kredel</a></address>
<p>
<!-- Created: Sat Mar 11 10:51:36 CET 2006 -->
<!-- hhmts start -->
Last modified: Sun Mar 12 14:24:20 CET 2006
<!-- hhmts end -->
</p>
<p align="right" >
$Id$
</p>
  </body>
</html>
