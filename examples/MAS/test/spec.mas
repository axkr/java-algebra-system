(* ----------------------------------------------------------------------------
 * $Id$
 * ----------------------------------------------------------------------------
 * This file is part of MAS.
 * ----------------------------------------------------------------------------
 * Copyright (c) 1989 - 1996 Universitaet Passau
 * ----------------------------------------------------------------------------
 * $Log$
 * Revision 1.1  2000/06/17 20:40:56  kredel
 * Initial revision
 *
 * Revision 1.1.1.1  2000/06/17 20:40:56  kredel
 * Clean import of MAS 1.0 from Uni Passau
 *
 * Revision 1.2  1996/06/20 12:50:13  pesch
 * Included .SPC files.
 *
 * Revision 1.1  1996/06/08 18:16:01  pesch
 * Renamed *.test to *.mas and added new tests.
 *
 * Revision 1.1  1992/01/30  12:21:17  kredel
 * Initial revision
 *
 * ----------------------------------------------------------------------------
 *)

CLOUT("Testing specification component ...").

 
BEGIN 
 CLOUT("Loading specifications ..."); 
 (*OUT("NUL:");*) x:=T; (* define T for parser *) 
 PRAGMA(SLOPPY);  
 (*PRAGMA(GENPARSE);  ensure non-generic parse *) 
END. 
 
(* ---------- specifications of abstract items --- *) 
 
SPECIFICATION OBJECT; 
(*Object specification. *) 
(*1*) SORT obj; 
(*2*) SIGNATURE READ     (obj) : obj; 
      SIGNATURE WRITE    (obj) ; 
(*3*) SIGNATURE DECREAD  (obj) : obj; 
      SIGNATURE DECWRITE (obj) ; 
(*4*) SIGNATURE DEFAULT  (obj) : obj; 
      SIGNATURE COERCE   (obj) : obj; 
(*9*) END OBJECT. 
 
 
SPECIFICATION AMONO; 
(*Abelian monoid specification. *) 
(*1*) IMPORT OBJECT[ amono/obj ]; 
(*2*) SIGNATURE ZERO (amono)       : amono; 
(*3*) SIGNATURE SUM  (amono,amono) : amono; 
(*9*) END AMONO. 
 
 
SPECIFICATION AGROUP; 
(*Abelian group specification. *) 
(*1*) IMPORT AMONO[ ag/amono ]; 
(*2*) SIGNATURE DIF  (ag,ag) : ag; 
      SIGNATURE NEG  (ag)    : ag; 
(*9*) END AGROUP. 
 
 
SPECIFICATION XRING; 
(*Ring specification extending A group. *) 
(*1*) IMPORT AGROUP[ xring/ag ]; 
(*2*) SIGNATURE ONE  (xring)       : xring; 
(*3*) SIGNATURE PROD (xring,xring) : xring; 
      SIGNATURE EXP  (xring,xring) : xring; 
(*9*) END XRING. 
 
 
SPECIFICATION RING; 
(*Ring specification combining an A group and an A moniod. *) 
(*1*) SORT atom; 
      IMPORT AGROUP[ ring/ag ]; 
      IMPORT AMONO [ ring/amono, ONE/ZERO, PROD/SUM ]; 
(*3*) SIGNATURE EXP  (ring,atom) : ring; 
(*9*) END RING. 
 
 
SPECIFICATION MODULE(Ring (*: spec*)); 
(*Module specification. *) 
(*1*) IMPORT AGROUP[ melem/ag ]; 
      (*IMPORT Ring;*) 
      SORT ring; 
(*3*) SIGNATURE SPROD (ring,melem) : melem; 
(*9*) END MODULE. 
 
 
SPECIFICATION ERING; 
(*Euclidean ring specification. *) 
(*1*) IMPORT RING[ er/ring ]; 
(*2*) SIGNATURE QR  (er,er,er,er) ; 
      SIGNATURE GCD (er,er)       : er; 
(*9*) END ERING. 
 
 
SPECIFICATION GBRING; 
(*Groebner base ring specification. *) 
      IMPORT RING[ gbring/ring ]; 
(*2*) SIGNATURE NF  (gbring,ring) : ring;             
      SIGNATURE GB  (gbring)      : gbring;             
      SIGNATURE IRR (gbring)      : gbring;             
(*9*) END GBRING. 
 
 
SPECIFICATION XFIELD; 
(*Field specification extending ring. *) 
(*1*) IMPORT RING[ xfield/ring ]; 
(*2*) SIGNATURE REZIP (xfield)        : xfield; 
      SIGNATURE Q     (xfield,xfield) : xfield; 
(*9*) END XFIELD. 
 
 
SPECIFICATION FIELD; 
(*Field specification combining two A groups. *) 
(*1*) SORT atom; 
      IMPORT AGROUP[ field/ag ]; 
      IMPORT AGROUP[ field/ag, ONE/ZERO, PROD/SUM, REZIP/NEG, Q/DIF ]; 
(*3 SIGNATURE EXP  (field ,atom) : field; *) 
(*9*) END FIELD. 
 
 
(* ----------- implementations of abstract items --- *) 
 
IMPLEMENTATION RING; 
(*1*) PROCEDURE EXP(X,n); 
      VAR   x: ring; 
      VAR   i: atom; 
      BEGIN  
      (*1*) IF n <= 0 THEN x:=ONE(X); RETURN(x) END; 
      (*3*) i:=n; x:=X;  
            WHILE i > 1 DO i:=i-1;  
                  x:=PROD(x,X) END; 
            RETURN(x) 
      (*9*) END EXP; 
(*9*) END RING. 

 
(* ---------- atom unit --- *) 
 
SPECIFICATION ATOM; 
(*Atoms specification. *) 
(*1*) SORT atom; 
(*2*) SIGNATURE Aone     ()          : atom; 
      SIGNATURE Azero    ()          : atom; 
(*3*) SIGNATURE MUL      (atom,atom) : atom; 
      SIGNATURE ADD      (atom,atom) : atom; 
      SIGNATURE SUB      (atom)      : atom; 
      SIGNATURE SUB      (atom,atom) : atom; 
      SIGNATURE POW      (atom,atom) : atom; 
      SIGNATURE QUOT     (atom,atom) : atom; 
      SIGNATURE REM      (atom,atom) : atom; 
(*4*) SIGNATURE Adefault ()          : atom; 
(*9*) END ATOM. 
 
 
IMPLEMENTATION ATOM; 
(*1*) PROCEDURE Aone(); 
      BEGIN RETURN(1) END Aone; 
(*2*) PROCEDURE Azero(); 
      BEGIN RETURN(0) END Azero; 
(*3*) PROCEDURE Adefault(); 
      BEGIN RETURN(0) END Adefault; 
(*9*) END ATOM. 
 
 
MODEL RING; 
(*Atoms are a model for rings. *) 
(*1*) IMPORT ATOM; 
      IMPORT INTEGER; 
(*2*) MAP READ(atom)       -> IREAD();  
      MAP WRITE(atom)      -> IWRITE(VAL); 
      MAP DEFAULT(atom)    -> Adefault(); 
(*3*) MAP ONE(atom)        -> Aone(); 
      MAP ZERO(atom)       -> Azero(); 
(*4*) MAP PROD(atom,atom)  -> MUL(VAL,VAL); 
      MAP SUM(atom,atom)   -> ADD(VAL,VAL); 
      MAP DIF(atom,atom)   -> SUB(VAL,VAL); 
      MAP NEG(atom)        -> SUB(VAL); 
(*9*) END RING. 
 
 
(* ---------- list unit --- *) 
 
SPECIFICATION Lists; (*LIST is a keyword ! *) 
(*List processing specification. *) 
(*1*) SORT list, object, atom; 
(*2*) SIGNATURE NullList ()                        : list; 
      SIGNATURE COMP     (object, list)            : list; 
      SIGNATURE LIST     (object, (*...,*) object) : list; 
      SIGNATURE CONC     (list,list)               : list; 
      SIGNATURE CCONC    (list,list)               : list; 
(*3*) SIGNATURE FIRST    (list)                    : object; 
      SIGNATURE RED      (list)                    : list; 
      SIGNATURE ADV      (list, object, list)      ; 
(*4*) SIGNATURE INV      (list)                    : list; 
      SIGNATURE CINV     (list)                    : list; 
(*5*) SIGNATURE SFIRST   (list,object)             ; 
      SIGNATURE SRED     (list,list)               ; 
(*7*) SIGNATURE EQUAL    (object,object)           : atom; 
      SIGNATURE LENGTH   (list)                    : atom; 
(*9*) END Lists. 
 
 
IMPLEMENTATION Lists;  
(*1*) PROCEDURE NullList(): list; 
      RETURN(LIST()) NullList; 
(*9*) END Lists. 
 
 
(* ---------- bool unit --- *) 
 
SPECIFICATION BOOL; 
(*Boolean specification. *) 
(*1*) SORT bool, object; 
(*2*) SIGNATURE true     ()              : bool; 
      SIGNATURE false    ()              : bool; 
(*3*) SIGNATURE EQ       (object,object) : bool; 
      SIGNATURE NE       (object,object) : bool; 
      SIGNATURE LE       (object,object) : bool; 
      SIGNATURE GE       (object,object) : bool; 
      SIGNATURE LT       (object,object) : bool; 
      SIGNATURE GT       (object,object) : bool; 
(*4   (*key words*)  
      SIGNATURE OR       (bool,bool)     : bool; 
      SIGNATURE AND      (bool,bool)     : bool; 
      SIGNATURE NOT      (bool)          : bool; 
      *) 
(*9*) END BOOL. 
 
 
IMPLEMENTATION BOOL; 
(*1*) PROCEDURE true(); 
      BEGIN RETURN(T) END true; 
(*2*) PROCEDURE false(); 
      BEGIN RETURN(LIST()) END false; 
(*9*) END BOOL. 
 
 
(* ----------- representation unit --- *) 
 
SPECIFICATION REPRESENTATION; 
(*Representation specification. *) 
(*1*) SORT elem, name, rep, pair, bool, func; 
(*2*) SIGNATURE NewRep       ()              : rep; 
      SIGNATURE SetRep       (name,elem,rep) ; 
      SIGNATURE GetRep       (name,rep)      : elem; 
      SIGNATURE CopyRep      (rep)           : rep; 
      SIGNATURE StepRep      (rep)           : pair; 
      SIGNATURE ForEachinRep (rep,func)      : rep; 
      SIGNATURE FullRep      (rep)           : bool; 
      SIGNATURE Pair         (name,elem)     : pair; 
      SIGNATURE NullPair     ()              : pair; 
(*9*) END REPRESENTATION. 
 
 
IMPLEMENTATION REPRESENTATION;  
(*1*) PROCEDURE Pair(a,b): pair; 
      RETURN(LIST(a,b)) Pair; 
(*2*) PROCEDURE NullPair(): pair; 
      RETURN(LIST()) NullPair; 
(*9*) END REPRESENTATION. 

 
(* ---------- integer unit --- *) 
 
SPECIFICATION INTEGER; 
(*Integral numbers specification. *) 
(*1*) SORT INT; 
(*2*) SIGNATURE IWRITE (INT)             ; 
      SIGNATURE IREAD  (INT)             : INT; 
(*3*) SIGNATURE Ione   ()                : INT; 
      SIGNATURE Izero  ()                : INT; 
(*4*) SIGNATURE IPROD  (INT,INT)         : INT; 
      SIGNATURE ISUM   (INT,INT)         : INT;             
      SIGNATURE IDIF   (INT,INT)         : INT; 
      SIGNATURE INEG   (INT)             : INT; 
      SIGNATURE IQR    (INT,INT,INT,INT) ; 
      SIGNATURE IGCD   (INT,INT)         : INT; 
(*9*) END INTEGER. 
 
 
IMPLEMENTATION INTEGER; 
(*1*) PROCEDURE Ione(); 
      BEGIN RETURN(1) END Ione; 
(*2*) PROCEDURE Izero(); 
      BEGIN RETURN(0) END Izero; 
(*9*) END INTEGER. 
 
 
MODEL RING; 
(*Integers are a model for rings. *) 
(*1*) IMPORT INTEGER; 
(*2*) MAP READ(INT)      -> IREAD();  
      MAP WRITE(INT)     -> IWRITE(VAL); 
(*3*) MAP ONE(INT)       -> Ione(); 
      MAP ZERO(INT)      -> Izero(); 
(*4*) MAP PROD(INT,INT)  -> IPROD(VAL,VAL); 
      MAP SUM(INT,INT)   -> ISUM(VAL,VAL); 
      MAP DIF(INT,INT)   -> IDIF(VAL,VAL); 
      MAP NEG(INT)       -> INEG(VAL); 
(*9*) END RING. 
 
 
(* ---------- rational number unit --- *) 
 
SPECIFICATION RATIONAL; 
(*Rational numbers specification. *) 
(*1*) SORT RAT, INT, atom; 
(*2*) SIGNATURE RNWRITE (RAT)     ; 
      SIGNATURE RNDRD   (RAT)     : RAT; 
(*3*) SIGNATURE RNone   ()        : RAT; 
      SIGNATURE RNzero  ()        : RAT; 
(*4*) SIGNATURE RNPROD  (RAT,RAT) : RAT; 
      SIGNATURE RNSUM   (RAT,RAT) : RAT; 
      SIGNATURE RNDIF   (RAT,RAT) : RAT; 
      SIGNATURE RNNEG   (RAT)     : RAT; 
      SIGNATURE RNINV   (RAT)     : RAT; 
      SIGNATURE RNQ     (RAT,RAT) : RAT; 
(*5*) SIGNATURE RNINT   (INT)     : RAT; 
      SIGNATURE RNprec  (atom)    ; 
(*9*) END RATIONAL. 
 
 
IMPLEMENTATION RATIONAL; 
      VAR s: atom; 
(*1*) PROCEDURE RNone(); 
      BEGIN RETURN(RNINT(1)) END RNone; 
(*2*) PROCEDURE RNzero(); 
      BEGIN RETURN(RNINT(0)) END RNzero; 
(*3*) PROCEDURE RNWRITE(a); 
      BEGIN IF s < 0 THEN RNWRIT(a) ELSE RNDWR(a,s) END;  
            END RNWRITE; 
(*4*) PROCEDURE RNprec(a); 
      BEGIN s:=a END RNprec; 
(*8*) BEGIN  
            s:=-1;  
(*9*) END RATIONAL. 
 
 
MODEL FIELD; 
(*Rational numbers are a model for fields. *) 
(*1*) IMPORT RATIONAL; 
(*2*) MAP READ(RAT)      -> RNDRD();  
      MAP WRITE(RAT)     -> RNWRITE(VAL); 
(*3*) MAP ONE(RAT)       -> RNone(); 
      MAP ZERO(RAT)      -> RNzero(); 
(*4*) MAP PROD(RAT,RAT)  -> RNPROD(VAL,VAL); 
      MAP SUM(RAT,RAT)   -> RNSUM(VAL,VAL); 
      MAP DIF(RAT,RAT)   -> RNDIF(VAL,VAL); 
      MAP NEG(RAT)       -> RNNEG(VAL); 
      MAP Q(RAT,RAT)     -> RNQ(VAL,VAL); 
      MAP REZIP(RAT)     -> RNINV(VAL); 
(*9*) END FIELD. 
 
 
(* ---------- modular integer unit --- *) 
 
SPECIFICATION MODINT; 
(*Modular integers specification. *) 
(*1*) SORT MI, INT, mod; 
(*2*) SIGNATURE MIWRIT (MI)         ; 
      SIGNATURE MIREAD (mod,MI)     : MI; 
(*3*) SIGNATURE MIone  (mod)        : MI; 
      SIGNATURE MIzero ()           : MI; 
(*4*) SIGNATURE MIPROD (mod,MI,MI)  : MI; 
      SIGNATURE MISUM  (mod,MI,MI)  : MI; 
      SIGNATURE MIDIF  (mod,MI,MI)  : MI; 
      SIGNATURE MINEG  (mod,MI)     : MI; 
      SIGNATURE MIINV  (mod,MI)     : MI; 
      SIGNATURE MIQ    (mod,MI,MI)  : MI; 
(*5*) SIGNATURE MIHOM  (mod,INT)    : MI; 
(*9*) END MODINT. 
 
 
IMPLEMENTATION MODINT; 
(*1*) PROCEDURE MIone(m); 
      BEGIN RETURN(MIHOM(m,1)) END MIone; 
(*2*) PROCEDURE MIzero(); 
      BEGIN RETURN(0) END MIzero; 
(*3*) PROCEDURE MIREAD(m); 
      BEGIN RETURN(MIHOM(m,IREAD())) END MIREAD; 
(*4*) PROCEDURE MIWRIT(x); 
      BEGIN IWRITE(x) END MIWRIT; 
(*9*) END MODINT. 
 
 
MODEL FIELD; 
(*Integers mod p are a model for fields. *) 
(*1*) IMPORT MODINT; 
      IMPORT INTEGER; 
(*2*) MAP READ(MI)      -> MIREAD(DESC);  
      MAP WRITE(MI)     -> MIWRIT(VAL); 
      MAP DECREAD(MI)   -> IREAD();  
      MAP DECWRITE(MI)  -> IWRITE(VAL); 
(*3*) MAP ONE(MI)       -> MIone(DESC); 
      MAP ZERO(MI)      -> MIzero(); 
(*4*) MAP PROD(MI,MI)   -> MIPROD(DESC,VAL,VAL) WHEN EQ(DESC,DESC); 
      MAP SUM(MI,MI)    -> MISUM(DESC,VAL,VAL)  WHEN EQ(DESC,DESC); 
      MAP DIF(MI,MI)    -> MIDIF(DESC,VAL,VAL)  WHEN EQ(DESC,DESC); 
      MAP NEG(MI)       -> MINEG(DESC,VAL); 
      MAP Q(MI,MI)      -> MIQ(DESC,VAL,VAL)    WHEN EQ(DESC,DESC); 
      MAP REZIP(MI)     -> MIINV(DESC,VAL); 
(*9*) END FIELD. 
 
 
(* ---------- floating point number unit --- *) 
 
SPECIFICATION FLOATING; 
(*Floating point numbers specification. *) 
(*1*) SORT FLOAT, INT, RAT, atom; 
(*2*) SIGNATURE APWRIT (FLOAT)       ; 
      SIGNATURE APREAD (FLOAT)       : FLOAT; 
(*3*) SIGNATURE APone  ()            : FLOAT; 
      SIGNATURE APzero ()            : FLOAT; 
(*2*) SIGNATURE APPROD (FLOAT,FLOAT) : FLOAT; 
      SIGNATURE APSUM  (FLOAT,FLOAT) : FLOAT; 
      SIGNATURE APDIF  (FLOAT,FLOAT) : FLOAT; 
      SIGNATURE APNEG  (FLOAT)       : FLOAT; 
      SIGNATURE APINV  (FLOAT)       : FLOAT; 
      SIGNATURE APQ    (FLOAT,FLOAT) : FLOAT; 
(*5*) SIGNATURE APFINT (INT)         : FLOAT; 
      SIGNATURE APFRN  (RAT)         : FLOAT; 
      SIGNATURE RNFAP  (FLOAT)       : RAT; 
      SIGNATURE APSPRE (atom)        ; 
(*9*) END FLOATING. 
 
 
IMPLEMENTATION FLOATING; 
(*1*) PROCEDURE APone(); 
      BEGIN RETURN(APFINT(1)) END APone; 
(*2*) PROCEDURE APzero(); 
      BEGIN RETURN(APFINT(0)) END APzero; 
(*3*) PROCEDURE APDIF(a,b); 
      BEGIN RETURN(APDIFF(a,b)) END APDIF; 
(*4*) PROCEDURE APINV(a); 
      BEGIN RETURN(APQ(APFINT(1),a)) END APINV; 
(*9*) END FLOATING. 
 
 
MODEL FIELD; 
(*AP floating numbers are (nearly) a model for fields. *) 
(*1*) IMPORT FLOATING; 
(*2*) MAP READ(FLOAT)        -> APREAD();  
      MAP WRITE(FLOAT)       -> APWRIT(VAL); 
(*3*) MAP ONE(FLOAT)         -> APone(); 
      MAP ZERO(FLOAT)        -> APzero(); 
(*4*) MAP PROD(FLOAT,FLOAT)  -> APPROD(VAL,VAL); 
      MAP SUM(FLOAT,FLOAT)   -> APSUM(VAL,VAL); 
      MAP DIF(FLOAT,FLOAT)   -> APDIF(VAL,VAL); 
      MAP NEG(FLOAT)         -> APNEG(VAL); 
      MAP Q(FLOAT,FLOAT)     -> APQ(VAL,VAL); 
      MAP REZIP(FLOAT)       -> APINV(VAL); 
(*9*) END FIELD. 
 

(* ---------- propositional logic unit --- *) 
 
SPECIFICATION PROPLOG; 
(*Propositional logic specification. *) 
(*1*) SORT bool; 
(*2*) SIGNATURE FALSE ()            : bool; 
      SIGNATURE TRUE  ()            : bool; 
(*3*) SIGNATURE land (bool,bool)     : bool; 
      SIGNATURE lor  (bool,bool)     : bool; 
      SIGNATURE lnot (bool)          : bool; 
      SIGNATURE implies (bool,bool) : bool; 
      SIGNATURE equival (bool,bool) : bool; 
      SIGNATURE test    (bool,bool) : bool; 
(*9*) END PROPLOG. 
 
 
AXIOMS PROPLOG; 
(*Axioms for propositional logic. *) 
(*1*) RULE lnot(TRUE())          => FALSE(); 
      RULE lnot(FALSE())         => TRUE(); 
(*2*) RULE land(TRUE(),TRUE())   => TRUE(); 
      RULE land(FALSE(),TRUE())  => FALSE(); 
      RULE land(TRUE(),FALSE())  => FALSE(); 
      RULE land(FALSE(),FALSE()) => FALSE(); 
(*3*) RULE lor(TRUE(),TRUE())    => TRUE(); 
      RULE lor(FALSE(),TRUE())   => TRUE(); 
      RULE lor(TRUE(),FALSE())   => TRUE(); 
      RULE lor(FALSE(),FALSE())  => FALSE(); 
(*4*) RULE implies(X,Y)         => lor(lnot(X),Y); 
      RULE equival(X,Y)         => land(implies(X,Y),implies(Y,X)); 
(*9*) END PROPLOG. 
 
 
(* ---------- peano arithmetic unit --- *) 
 
SPECIFICATION PEANO; 
(*Peano structure specification. *) 
(*1*) SORT nat; 
      IMPORT PROPLOG; 
(*2*) SIGNATURE null  ()        : nat; 
      SIGNATURE one   ()        : nat; 
   (* SIGNATURE succ  (nat)     : nat; *) 
      SIGNATURE add   (nat,nat) : nat; 
      SIGNATURE prod  (nat,nat) : nat; 
(*3*) SIGNATURE equal (nat,nat) : bool; 
   (* SIGNATURE pred  (nat)     : bool; *) 
(*9*) END PEANO. 
 
 
AXIOMS PEANO; 
(*Axioms for Peano system. *) 
      RULE equal(X,X)                 => TRUE(); 
      RULE equal(succ(X),null())      => FALSE(); 
      RULE equal(null(),succ(X))      => FALSE(); 
(*1*) RULE equal(succ(null()),null()) => FALSE(); 
(*2*) RULE equal(succ(X),succ(Y))     => equal(X,Y); 
(*3*) RULE add(X,null())              => X; 
(*4*) RULE add(X,succ(Y))             => succ(add(X,Y)); 
(*5*) RULE prod(X,null())             => null(); 
(*6*) RULE prod(X,succ(Y))            => add(prod(X,Y),X); 
      (*additional equations "lemmas" *) 
      RULE add(succ(X),Y)             => succ(add(X,Y)); 
      RULE add(null(),X)              => X; 
      RULE prod(succ(X),Y)            => add(X,prod(X,Y)); 
      RULE prod(null(),X)             => null(); 
      RULE one()                      => succ(null()); 
(*9*) END PEANO. 
 
 
MODEL RING; 
(*Peano numbers are a model for rings, except subtract. *) 
(*1*) IMPORT PEANO; 
(*2*) MAP WRITE(nat)     -> MWRITE(VAL); 
(*3*) MAP ONE(nat)       -> one(); 
      MAP ZERO(nat)      -> null(); 
(*4*) MAP PROD(nat,nat)  -> prod(VAL,VAL); 
      MAP SUM(nat,nat)   -> add(VAL,VAL); 
(*9*) END RING. 
 
(* ---------- integer recursive polynomial unit --- *)

SPECIFICATION IPOL;
(*Integer recursive polynomial specification. *)
(*1*) SORT ipol, pol, dip, atom;
(*2*) SIGNATURE IPzero ()                : ipol;
      SIGNATURE IPSUM  (atom,ipol,ipol)  : ipol;            
      SIGNATURE IPNEG  (atom,ipol)       : ipol;
      SIGNATURE IPDIF  (atom,ipol,ipol)  : ipol;
(*3*) SIGNATURE IPPROD (atom,ipol,ipol)  : ipol;
      SIGNATURE IPEXP  (atom,ipol,ipol)  : ipol;
(*4*) SIGNATURE PFDIP  (dip,atom,pol)    ;
(*9*) END IPOL.


IMPLEMENTATION IPOL;
(*2*) PROCEDURE IPzero();
      BEGIN RETURN(0) END IPzero;
(*2*) PROCEDURE IPDIF(r,a,b);
      BEGIN RETURN(IPSUM(r,a,IPNEG(r,b))) END IPDIF;
(*9*) END IPOL.


MODEL RING;
(*Integer recursive polynomial are a model for rings. *)
(*1*) IMPORT IPOL;
(*2*) MAP ZERO(ipol)      -> IPzero();
      MAP SUM(ipol,ipol)  -> IPSUM(DESC,VAL,VAL)  WHEN EQ(DESC,DESC);
      MAP NEG(ipol)       -> IPNEG(DESC,VAL);
      MAP DIF(ipol,ipol)  -> IPDIF(DESC,VAL,VAL)  WHEN EQ(DESC,DESC);
(*3*) MAP PROD(ipol,ipol) -> IPPROD(DESC,VAL,VAL) WHEN EQ(DESC,DESC);
      MAP EXP(ipol,atom)  -> IPEXP(DESC,VAL,VAL);
(*9*) END RING.


(* ---------- distributive rational polynomial unit --- *)

SPECIFICATION DIRP;
(*Distributive rational polynomial specification. *)
(*1*) SORT dip, dirp, diip, pol, atom;
(*2*) SIGNATURE DIRPSM (dirp,dirp)         : dirp;            
      SIGNATURE DIRPNG (dirp)              : dirp;
      SIGNATURE DIRPDF (dirp,dirp)         : dirp;
(*3*) SIGNATURE DIRPPR (dirp,dirp)         : dirp;
(*4*) SIGNATURE DIPFP  (atom,pol)          : dip;
(*6*) SIGNATURE DIIFRP (dirp)              : diip;
      SIGNATURE DIRFIP (diip)              : dirp;
(*9*) END DIRP.


IMPLEMENTATION DIRP;
(*2*) PROCEDURE DIRPDF(a,b);
      BEGIN RETURN(DIRPSM(a,DIRPNG(b))) END DIRPDF;
(*9*) END DIRP.


MODEL RING;
(*Distributive rational polynomial are a model for rings. *)
(*1*) IMPORT DIRP;
(*2*) MAP SUM(dirp,dirp)  -> DIRPSM(VAL,VAL);
      MAP NEG(dirp)       -> DIRPNG(VAL);
      MAP DIF(dirp,dirp)  -> DIRPDF(VAL,VAL);
(*4*) MAP PROD(dirp,dirp) -> DIRPPR(VAL,VAL);
      MAP EXP(dirp,dirp)  -> DIRPEX(VAL,VAL);
(*9*) END RING.


(* ---------- distributive rational polynomial list unit --- *)

SPECIFICATION DIRL;
(*Distributive rational polynomial list specification. *)
(*1*) SORT dip, dirp, diip, pol, atom, dc;
(*2*) SIGNATURE PDREAD  ()          : dc;            
      SIGNATURE PDWRITE (dc)        ;            
(*3*) SIGNATURE DIRLRD  ()          : dirl;            
      SIGNATURE DIRLWR  (dirl)      ;            
      SIGNATURE PREADD  (dc)        : dirl;            
      SIGNATURE PWRITED (dirl)      ;            
(*4*) SIGNATURE DIILFR  (dirl)      : diil;            
(*5*) SIGNATURE DIRPNF  (dirl,dirp) : dirp;            
      SIGNATURE DIRPGB  (dirl,atom) : dirl;            
      SIGNATURE DIRPGB1 (dirl)      : dirl;            
      SIGNATURE DIRLIS  (dirl)      : dirl;            
(*6*) SIGNATURE SetTflag(atom)      ;            
(*9*) END DIRL.


IMPLEMENTATION DIRL;
(*Distributive rational polynomial list implementation. *)
      VAR s: atom;
(*2*) PROCEDURE DIRPGB1(a) : dirl;
      BEGIN RETURN(DIRPGB(a,s)) END DIRPGB1;            
(*3*) PROCEDURE SetTflag(a);
      BEGIN s:=a END SetTflag;            
(*4*) BEGIN 
            s:=1;      
(*9*) END DIRL.


MODEL OBJECT;
(*Distributive rational polynomial lists are a model for objects. *)
(*1*) IMPORT DIRL;
(*2*) MAP DECREAD(dirl)   -> PDREAD();
      MAP DECWRITE(dirl)  -> PDWRITE(VAL);
(*3*) MAP READ(dirl)      -> PREADD(DESC);
      MAP WRITE(dirl)     -> PWRITED(DESC,VAL);
(*9*) END OBJECT.


(* ---------- gb structure unit --- *)

MODEL GBRING;
(*Distributive rational polynomial lists are a model for 
Groebner base rings. *)
      IMPORT DIRL;
(*2*) MAP NF(dirl,dirp) -> DIRPNF(VAL,VAL);
      MAP GB(dirl)      -> DIRPGB1(VAL);
      MAP IRR(dirl)     -> DIRLIS(VAL);
(*9*) END GBRING.

CLOUT(" ... exposing units ... "). 
 
(*specifics. *) 
EXPOSE ATOM.  
EXPOSE REPRESENTATION.  
EXPOSE Lists.  
 
EXPOSE INTEGER.  
EXPOSE RATIONAL. 
EXPOSE MODINT.  
EXPOSE FLOATING.  
 
EXPOSE PROPLOG. 
EXPOSE PEANO. 
 
EXPOSE IPOL. 
EXPOSE DIRP. 
EXPOSE DIRL. 
 
(*generics. *) 
EXPOSE OBJECT.  
EXPOSE AGROUP.  
EXPOSE FIELD.  
EXPOSE RING.  
EXPOSE GBRING.  
 
BEGIN  
 PRAGMA(FUSSY);  
END. 
 
PRAGMA(GENPARSE).

 
(*Arithmetic units. *)

VAR i, j : INT.

i:="111111111111111111111111111111111111111111111111111111111111".

j:=i^2.

j:=j^0-i*i+j.

j:=j+ "333333333333333333": INT -j.



VAR r, s: RAT.

r:="2222222222.777777777777777".

s:=r/r.

s:=r^0+s- "1": RAT.



VAR m, n: MI "7".

m:="11111111111111111111111111".

n:=m/m.

n:=m^0+n- "8": MI "7".



VAR f, g: FLOAT.

f:="2222.3E10".

g:=f^3.

g:=f/g.

g:=g*f*f.



(*Term units. *)

x:=one().

x:=add(x,x).

y:=prod(x,x).



(*Polynomial unit. *)

(*Example from Trinks 6/7. *)
(*Syntax: "<variable list> <term order>" *)

VAR p, q: dirl "(B,S,T,Z,P,W) L".  

(*Syntax: "<polynomial list>" *)

p:="(
    ( 45 P + 35 S - 165 B - 36 ),
    ( 35 P + 40 Z + 25 T - 27 S ),
    ( 15 W + 25 S P + 30 Z - 18 T - 165 B**2 ),
    ( - 9 W + 15 T P + 20 S Z ),
    ( P W + 2 T Z - 11 B**3 ),
    ( 99 W - 11 B S + 3 B**2 )
    ( B**2 + 33/50 B + 2673/10000 )
    )".

 
q:=GB(p).


PRAGMA(GENPARSE).

(* -EOF- *)
