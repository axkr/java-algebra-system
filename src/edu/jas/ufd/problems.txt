
- C in GenPolynomial<C> must implement GcdRingElem<C>
  to allow base coefficient gcds: a.gcd(b)

- GenPolynomial<C> cannot implement GcdRingElem<C> because 
  no meaningful gcd can be defined for multivariate polynomials 
  in this class

- so GenPolynomial<GenPolynomial<C>> is not a valid type 
  for gcd computations

- so we have three methods to distinguish

  * GenPolynomial<C> 
     baseGcd( GenPolynomial<C> P, GenPolynomial<C> S )

  for univariate polynomials over a gcd ring


  * GenPolynomial<GenPolynomial<C>> 
     recursiveGcd( GenPolynomial<GenPolynomial<C>> P,
                   GenPolynomial<GenPolynomial<C>> S ) 

  for univariate polynomials with multivariate polynomials as
  coefficients

  
  * GenPolynomial<C> 
     gcd( GenPolynomial<C> P, GenPolynomial<C> S )

  for the general case, decides baseGcd or setup for recursion

- possible solutions

  let this class extend GenPolynomial, e.g. 

      GcdGenPolynomial<C extends GcdRingElem<C>>
         extends GenPolynomial<C>

  result would be

  GcdGenPolynomial<GcdGenPolynomial<C>> 
     recursiveGcd( GcdGenPolynomial<GcdGenPolynomial<C>> P,
                   GcdGenPolynomial<GcdGenPolynomial<C>> S ) 


  GcdGenPolynomial<C> 
     baseGcd( GcdGenPolynomial<C> P, GcdGenPolynomial<C> S ) 

  both not possible since RingELem cannot be implemented with 
  different type parameters

- let GenPolynomial already implement GcdRingElement
  but it cannot be guaranteed, that gcd always is implemented 
  or exists 
  in case if inverse() the type RingElem does not guarantee that 
  inverse() does not fail, 
  but GcdRingElem should guarantee that gcd does not fail

- let RingElem define gcd() with no quarantee
  requires 10 classes to additionaly implement gcd

- let GenPolynomial implement GcdRingElem
  eventually with GcdRingElem as Coefficients
  only GcdRingElem itself requires nothing more
  if coeffients are required as GcdRingElem then 
  about 100+ C type restrictions have to be adjusted, 
  i.e. nearly all classes must be changed

- make GcdRingElem only a marker interface and let RingElem implement gcd

- extended gcd and half extended gcd not implemented f√ºr multivariate case

- Axiom defines gcd method in polynomial category

- define new recursive polynomial type 
  RecPolynomial<C extends RingElem<C>> or
  RecPolynomial<C extends RecPolynomial<C>>
  how to handle recursion base or recursion itself?
  nvar == 0: C a = coefficient(); ... a.multiply(b)
  nvar == 1: Collection<C> A = val.getValues(); ... a[i].multiply(b[i])
  nvar  > 1: Collection<RecPolynomial<C>> A = val.getValues(); ... a[i].multiply(b[i])
  val : Map<Long,C> or Map<Long,RecPolynomial<C>>


== problems with the new algorithms ==

- basically using distributed representation with conversions to 
  recursive representiation on demand/requirements

- conversion time between distributed and recursive representation

- choice of prime size, le long.maxValue or le int.maxValue

- explicit data type for long or int methods instead of BigInteger

- bad bounds to stop iteration over primes or elements of prime fields

- are bounds better for gcd with cofactors computation

- manipulation of ring factories

- slow univariate polynomial methods

- redundant/superflous debug assertion checks

- inappropriate gcd content computation methods

== positives ==

- interface with only most usefull methods

- implemented gcd, cont, pp, res, lcm, squarefreePart, squarefreeFactors

- generic algorithm works for all field coefficients

- abstract class with full set of methods

- implementations of only two methods for different algorithms

- factory for the choice of the best algorithm based on the coefficient type

- special cases for BigInteger and ModInteger coefficients

- timing of modular methods not jet good

- new proxy class with gcd interface and parallel execution of two different
  gcd algorithms - timing is max 2 times best algorithm
