<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>jas project users guide</title>
<style type="text/css">
body { background-color: #FFFFF5; } 
pre  { background-color: silver; 
       margin-left: 1em; 
       margin-right: 1em; 
       padding: 1em; 
     }
dt   { font-weight: bolder; 
       margin-top: 1em;
     }
.note { color: maroon; }
</style>

  </head>

  <body>
    <h1>Jas Project</h1>

<h2>Users Guide</h2>

<p>
This document contains some (first) how to and usage 
information for the JAS project.
JAS can be used as any other Java library by adding <code>jas.jar</code> 
to the classpath and creating and using objects from it.
JAS can also be used interactively via the Python Java interpreter 
<code>jython</code>. 
</p>


<h3>Getting started</h3>

<p>
As first example we will discus how to compute a Groebner base with
<code>jython</code>. The jython script will be placed into a file, e.g.
<a href="examples/getstart.py"><code>getstart.py</code></a>. 
This script file is executed by calling
</p>
<pre>
  jython getstart.py
</pre>
<p>
The script file first imports the desired mathematical classes from the 
<code>jas.py</code> script which does all interfacing to the Java library.
</p>
<pre>
  from jas import Ring
  from jas import Ideal
</pre>
<p>
In our case we need <code>Ring</code> to define an appropriate polynomial ring
and <code>Ideal</code> to define sets of polynomials and have methods to 
compute Groebner bases. 
<code>Ring</code> takes a string argument which contains required definitions 
of the polynomial ring: the type of the coefficient ring, the names of 
the used variables and the desired term order.
</p>
<pre>
  r = Ring( "Rat(B,S,T,Z,P,W) L" );
</pre>
<p>
The ring definition is stored in the variable <code>r</code> for later use.
The string <code>"Rat(B,S,T,Z,P,W) L"</code> defines the coefficient ring 
to be the rational numbers <code>Rat</code>,
the polynomial ring consists of the variables <code>B, S, T, Z, P, W</code>
and the term order <code>L</code> means a lexicographic term order.
For some historical reason the term order orders the variables as 
<code>B &lt; S &lt; T &lt; Z &lt; P &lt; W</code> and not the other way. 
I.e. the highest or largest variable is always on the left of the list of
variables not on the right as in some other algebra systems.
With 
</p>
<pre>
  print "Ring: " + str(r);
</pre>
<p>
you can print out the ring definition. 
<code>str(r)</code> is the usual python way of producing string representations
of objects, which in our case calls the respective Java method 
<code>toString()</code> of the JAS ring object. It produces
</p>
<pre>
Ring: BigRational(B, S, T, Z, P, W) INVLEX
</pre>
<p>
i.e. the coefficients are from the jas class <code>BigRational</code>
and the term order is <code>INVLEX</code> 
(<code>INV</code> because the largest variable is on the left).
Next we need to enter the generating polynomials for the ideal. 
We do this in two steps, first define a python string with the polynomials 
and then the creation of the ideal using the ring definition from before 
and the polynomial string.
</p>
<pre>
ps = """
( 
 ( 45 P + 35 S - 165 B - 36 ), 
 ( 35 P + 40 Z + 25 T - 27 S ), 
 ( 15 W + 25 S P + 30 Z - 18 T - 165 B**2 ), 
 ( - 9 W + 15 T P + 20 S Z ), 
 ( P W + 2 T Z - 11 B**3 ), 
 ( 99 W - 11 B S + 3 B**2 ),
 ( B**2 + 33/50 B + 2673/10000 )
) 
""";
</pre>
<p>
The polynomial string can be generated by any means python allows for 
string manipulation. 
In our example we use python multiline strings, which are delimited by 
triple quotes <code>""" ... """</code>.
The list of polynomials is delimited by parenthesis <code>( ... )</code>,
as well as every polynomial is delimited by parenthesis, e.g.
<code>( B**2 + 33/50 B + 2673/10000 )</code>.
The polynomials are separated by commas.
The syntax for polynomials is a sequence of monimals consisting 
of coefficients and terms (as products of powers of variables).
The terms can optionally be written with multiplication sign,  
i.e. <code>25 S P</code> can be written <code>25*S*P</code>. 
Variable names must be delimited by white space or some operator,
i.e. you can not write <code>25 SP</code> because <code>SP</code>
is not a listed variable name in the polynomial ring definition.
Coefficients may not contain white space, i.e. the <code>/</code>
separating the nominator from the denominator may not be surrounded 
by spaces, i.e. writing <code>33 / 50</code> is not allowed.
Powers of variables can be written with <code>**</code> or <code>^</code>,
i.e. the square of <code>B</code> is written as <code>B**2</code>
or <code>B^2</code>.
The ideal is the defined with
</p>
<pre>
  f = Ideal( r, ps );
</pre>
<p>
The ideal is contained the the polynomial ring <code>r</code>
and consists of the polynomials from the string <code>ps</code>.
Ideals can be printed with
</p>
<pre>
  print "Ideal: " + str(f);
</pre>
<p>
In this example it produces the following output.
</p>
<pre>
Ideal: BigRational(B, S, T, Z, P, W) INVLEX
(
( B^2 + 33/50 B + 2673/10000  ),
( 45 P + 35 S - 165 B - 36  ),
( 35 P + 40 Z + 25 T - 27 S ),
( 15 W + 25 S * P + 30 Z - 18 T - 165 B^2 ),
( -9 W + 15 T * P + 20 S * Z ),
( 99 W - 11 B * S + 3 B^2 ),
( P * W + 2 T * Z - 11 B^3 )
)
</pre>
<p>
The polynomial terms are now sorted with respect to the lexicographical 
term order. The highest term is first in a polynomial.
Also the polynomials are sorted with respect to the term order, but
with smallest polynomial first in the list.
Finaly we can go to the computation of the Groebner basis of this ideal.
</p>
<pre>
  g = f.GB();
</pre>
<p>
The ideal <code>f</code> has a method <code>GB()</code> which 
computes the Groebner base. The computed Groebner base is stored
in the variable <code>g</code> which is also an ideal.
It can be printed as the ideal <code>f</code>
</p>
<pre>
  print "Groebner base:", g;
</pre>
<p>
The output first shows the output from calling the <code>GB()</code> method
and the the ideal basis.
</p>
<pre>
sequential executed in 136 ms

Groebner base: BigRational(B, S, T, Z, P, W) INVLEX
(
( B^2 + 33/50 B + 2673/10000  ),
( S - 5/2 B - 9/200  ),
( T - 37/15 B + 27/250  ),
( Z + 49/36 B + 1143/2000  ),
( P - 31/18 B - 153/200  ),
( W + 19/120 B + 1323/20000  )
)
</pre>
<p>I.e. the Groebner base was computed in 135 ms and consists 
of six polynomials. The polynomials are now monic, 
i.e. the leading coefficient is 1 and omitted during print out.
This concludes the getting started section.
</p>


<h3>Overview of jas.py classes and methods</h3>


<h3>Some internals of jas.py</h3>

<!--
<pre>
</pre>

<p>
</p>
<pre>
</pre>

<p>
</p>
<pre>
</pre>
-->

<hr />
<address><a href="mailto:kredel@at@rz.uni-mannheim.de">Heinz Kredel</a></address>
<p>
<!-- Created: Sun Feb 19 15:49:14 CET 2006 -->
<!-- hhmts start -->
Last modified: Sun Feb 19 17:22:57 CET 2006
<!-- hhmts end -->
</p>
<p align="right" >
$Id: $
</p>
  </body>
</html>
